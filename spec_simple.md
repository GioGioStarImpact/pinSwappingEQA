# Pin Swapping 等價性演算法 - 簡化版

## 1. 我們要解決什麼問題？

### 問題描述

想像你有一個邏輯晶片（例如 AND 閘、XOR 閘），這個晶片有：
- **輸入腳位** (A1, A2, A3, ...)：接收外部訊號
- **輸出腳位** (Z1, Z2, ...)：送出計算結果

**問題是**：如果我把輸入腳位的接線順序交換（例如原本 net1 接 A1、net2 接 A2，改成 net1 接 A2、net2 接 A1），整體功能會改變嗎？

有些晶片的腳位是**對稱的**（交換不影響功能），有些則不是。這個演算法要找出**哪些接線方式是功能上等價的**。

### 生活化比喻

就像插座上的兩孔：
- 台灣的**交流電插座**兩孔是對稱的，插反也能用 → 等價
- **USB 插頭** (舊式) 正反面不對稱，插反無法使用 → 不等價

### 基本術語

| 術語 | 說明 | 範例 |
|------|------|------|
| **N** | 輸入腳位數量 | N=3 表示有 A1, A2, A3 三個輸入 |
| **M** | 輸出腳位數量 | M=2 表示有 Z1, Z2 兩個輸出 |
| **真值表 F** | 晶片的完整功能表 | F[0]=0 表示「所有輸入為 0 時，輸出為 0」 |
| **排列 π** | 描述「哪條線接到哪個腳位」 | π=(0,1,2): net1→A1, net2→A2, net3→A3（沒交換）<br>π=(1,0,2): net1→A2, net2→A1, net3→A3（前兩個交換） |

---

## 2. 演算法如何運作？

### 整體流程（三步驟）

```
┌────────────────────────────────────────────────┐
│ 步驟 1: 列舉所有可能的接線方式                 │
│   • 3 個輸入有 3! = 6 種接法                   │
│   • 8 個輸入有 8! = 40320 種接法（太多！）     │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ 步驟 2: 對每種接線方式計算「指紋」             │
│   • 把每種接法的功能轉換成一組數字             │
│   • 功能相同的接法會有相同的指紋               │
└────────────────────────────────────────────────┘
                    ↓
┌────────────────────────────────────────────────┐
│ 步驟 3: 把指紋相同的接法歸為一類               │
│   • 每一類都是功能上等價的接法                 │
│   • 輸出結果: {指紋 → 等價接法列表}            │
└────────────────────────────────────────────────┘
```

---

## 3. 三個核心概念（白話說明）

### 概念 1: 外部訊號 vs 晶片腳位

這是兩個不同的「視角」：

| 視角 | 符號 | 說明 | 範例 |
|------|------|------|------|
| **外部訊號** | t | 電路板上的訊號線狀態 | t=5 (二進位 101) 表示 net1=1, net2=0, net3=1 |
| **晶片腳位** | u | 晶片實際看到的腳位狀態 | u=3 (二進位 011) 表示 A1=1, A2=1, A3=0 |

**為什麼會不同？**
因為中間有接線！如果 net1 接到 A2，那麼 net1 的訊號會跑到 A2 腳位上。

**轉換過程**：
```
外部訊號 t → (根據接線圖 π 轉換) → 晶片看到的 u → (查真值表 F) → 輸出
```

#### 範例說明

假設有 3 個輸入，接線方式為 π = (1, 0, 2)，表示：
- net1 → A2 (接到第 2 個腳位，索引為 1)
- net2 → A1 (接到第 1 個腳位，索引為 0)
- net3 → A3 (接到第 3 個腳位，索引為 2)

當外部訊號 t = 5 (二進位 101，即 net1=1, net2=0, net3=1) 時：
- A1 收到 net2 的訊號 = 0
- A2 收到 net1 的訊號 = 1
- A3 收到 net3 的訊號 = 1
- 所以 u = 6 (二進位 110)

---

### 概念 2: 輸出函數的「指紋」(Bitvector)

對於每個輸出腳位（例如 Z1），我們想知道：
> **在所有可能的外部訊號組合下，這個輸出腳位會輸出什麼？**

這可以用一個**二進位數字**來表示，稱為 **bitvector**。

#### 範例說明

假設 N=3（有 2³=8 種外部訊號組合，t = 0, 1, 2, ..., 7）

Z1 的 bitvector = `0b00110100` (十進位 52)

**意義**：
```
bit 位置 (t):  7  6  5  4  3  2  1  0
bit 值:        0  0  1  1  0  1  0  0
               ↑     ↑  ↑     ↑
              t=7   t=5 t=4  t=2 時 Z1=1
```

換句話說：
- t=0 → Z1=0
- t=1 → Z1=0
- t=2 → Z1=1 ✓
- t=3 → Z1=0
- t=4 → Z1=1 ✓
- t=5 → Z1=1 ✓
- t=6 → Z1=0
- t=7 → Z1=0

#### 如何計算 Bitvector？

```python
# 初始化: M 個輸出，每個 bitvector 初始為 0
g = [0] * M

# 遍歷所有可能的外部訊號 t
for t in range(2^N):  # t = 0, 1, 2, ..., 2^N-1
    # 1. 根據接線 π 將外部訊號 t 轉換成晶片輸入 u
    u = net_pattern_to_pin_pattern(t, π, N)

    # 2. 查詢真值表，得到輸出
    z = F[u]  # z 是一個 M-bit 的數字，包含所有輸出值

    # 3. 將每個輸出的結果記錄到對應的 bitvector
    for j in range(M):
        if (z 的第 j 個 bit 是 1):
            g[j] 的第 t 個 bit 設為 1
```

**重點**：bitvector 是從**外部視角**看輸出函數的完整真值表。

---

### 概念 3: 標準化指紋 (Canonical Signature)

**問題**：兩個接線方式怎麼比較是否等價？

**答案**：計算每個接線方式的「標準化指紋」，指紋相同 = 功能等價。

#### 什麼是標準化指紋？

把所有輸出的 bitvector **排序**後組成的 tuple。

#### 為什麼要排序？

因為**輸出腳位通常可以任意交換**（Z1 和 Z2 互換，整體功能不變）。

排序後，不管輸出順序如何，相同功能會得到相同指紋。

#### 範例

假設有兩個接線方式：

**接線 A**:
- Z1 的 bitvector = `0b00110100` (52)
- Z2 的 bitvector = `0b11001000` (200)
- 指紋 = `(52, 200)` ← 排序後小的在前

**接線 B**:
- Z1 的 bitvector = `0b11001000` (200)
- Z2 的 bitvector = `0b00110100` (52)
- 指紋 = `(52, 200)` ← 排序後一樣！

**結論**：接線 A 和 B 功能等價（只是輸出順序不同）。

#### 指紋計算流程

```python
def canonical_signature(F, N, M, π):
    # 步驟 1: 計算所有輸出的 bitvector
    g = build_output_functions_bitvectors(F, N, M, π)
    # g = [52, 200] 或 [200, 52]

    # 步驟 2: 排序
    signature = tuple(sorted(g))
    # signature = (52, 200)

    return signature
```

---

## 4. 完整演算法流程

### 主函數: partition_tuples

**目標**: 將所有可能的接線方式分類成等價類別。

```python
def partition_tuples(F, N, M):
    sig2pis = {}  # 字典: {指紋 → 接線方式列表}

    # 步驟 1: 列舉所有可能的輸入排列
    for π in all_permutations(N):  # N! 種排列

        # 步驟 2: 計算這個排列的標準化指紋
        sig = canonical_signature(F, N, M, π)

        # 步驟 3: 根據指紋分類
        if sig not in sig2pis:
            sig2pis[sig] = []
        sig2pis[sig].append(π)

    return sig2pis
```

### 輸出結果

```python
{
    (52, 200): [(0,1,2), (0,2,1), ...],  # 第一類: 6 種等價接法
    (100, 150): [(1,0,2), ...],          # 第二類: 3 種等價接法
    ...
}
```

每一類中的所有接線方式都是功能上等價的。

---

## 5. 實際範例

### 範例元件: 3 輸入 2 輸出

定義一個簡單的邏輯元件：
- **Z1 = A1 AND A2** (A1 和 A2 同時為 1 時，Z1 才是 1)
- **Z2 = A2 XOR A3** (A2 和 A3 不同時，Z2 是 1)

#### 真值表 F

| u (二進位) | A3 | A2 | A1 | Z1 | Z2 | F[u] |
|-----------|----|----|----|----|-------|------|
| 0 (000) | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 (001) | 0 | 0 | 1 | 0 | 0 | 0 |
| 2 (010) | 0 | 1 | 0 | 0 | 1 | 2 |
| 3 (011) | 0 | 1 | 1 | 1 | 1 | 3 |
| 4 (100) | 1 | 0 | 0 | 0 | 1 | 2 |
| 5 (101) | 1 | 0 | 1 | 0 | 1 | 2 |
| 6 (110) | 1 | 1 | 0 | 0 | 0 | 0 |
| 7 (111) | 1 | 1 | 1 | 1 | 0 | 1 |

#### 分析接線 π = (0, 1, 2)

這是**恆等排列**（沒有交換）：net1→A1, net2→A2, net3→A3

**計算 Z1 的 bitvector**：

| t | net3 | net2 | net1 | u (=t) | F[u] | Z1 | Z2 |
|---|------|------|------|--------|------|----|----|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 1 | 1 | 0 | 0 | 0 |
| 2 | 0 | 1 | 0 | 2 | 2 | 0 | 1 |
| 3 | 0 | 1 | 1 | 3 | 3 | 1 | 1 |
| 4 | 1 | 0 | 0 | 4 | 2 | 0 | 1 |
| 5 | 1 | 0 | 1 | 5 | 2 | 0 | 1 |
| 6 | 1 | 1 | 0 | 6 | 0 | 0 | 0 |
| 7 | 1 | 1 | 1 | 7 | 1 | 1 | 0 |

- Z1 的 bitvector = `0b10001000` (在 t=3 和 t=7 時為 1)
- Z2 的 bitvector = `0b00111100` (在 t=2,3,4,5 時為 1)
- 指紋 = `(0b00111100, 0b10001000)` = (60, 136)

---

## 6. 演算法複雜度

### 時間複雜度

| 操作 | 複雜度 | 說明 |
|------|--------|------|
| 計算單一 bitvector | O(2^N × M) | 遍歷所有外部訊號組合 |
| 計算單一指紋 | O(2^N × M) | bitvector + 排序 (M 很小) |
| 完整分類 | **O(N! × 2^N × M)** | 遍歷所有輸入排列 |

### 可行性分析

| N | N! | 2^N | 總計算量 | 可行性 |
|---|-----|-----|---------|--------|
| 3 | 6 | 8 | 48 | ✓✓✓ 非常快 |
| 4 | 24 | 16 | 384 | ✓✓ 很快 |
| 5 | 120 | 32 | 3,840 | ✓ 可行 |
| 6 | 720 | 64 | 46,080 | △ 邊界 |
| 8 | 40,320 | 256 | 10,321,920 | ✗ 太慢 |
| 10 | 3,628,800 | 1,024 | 3,715,891,200 | ✗✗ 不可行 |

**關鍵瓶頸**: N! (階乘) 增長太快，當 N ≥ 8 時不可行。

---

## 7. 程式碼結構

### 核心函數一覽

```
bits_to_int()               將 bit 陣列轉整數
    ↓
parse_truth_table_rows()    解析真值表
    ↓
inverse_perm()              計算排列的反函數
    ↓
net_pattern_to_pin_pattern()  外部訊號 → 晶片腳位
    ↓
build_output_functions_bitvectors()  計算 bitvector
    ↓
canonical_signature_for_pi()  計算標準化指紋
    ↓
partition_tuples()          分類所有排列
```

### 函數關係圖

```
partition_tuples
    └─ for each π:
        └─ canonical_signature_for_pi
            └─ build_output_functions_bitvectors
                ├─ inverse_perm
                └─ for each t:
                    ├─ net_pattern_to_pin_pattern
                    └─ F[u] (查真值表)
```

---

## 8. 限制與改進方向

### 當前限制

1. **可擴展性**: N ≥ 8 時因 N! 過大而不可行
2. **輸出顯示**: verbose 模式在 N ≥ 8 時會產生過長的二進位字串
3. **假設**: 假設所有輸出腳位可任意交換（實際上可能有限制）

### 未來改進

1. **對稱性預檢測**: 用代數方法預先偵測對稱性，減少需要檢查的排列
2. **平行化**: 不同排列的計算可以平行處理
3. **更好的輸出格式**: 大規模 bitvector 用十六進位或壓縮格式顯示
4. **進階演算法**: 使用 BDD (Binary Decision Diagram) 或 SAT solver 等技術

---

## 9. 總結

這個演算法的核心思想很簡單：

1. **窮舉所有接線方式** (N! 種)
2. **計算每種接線的功能指紋** (bitvector 排序後)
3. **指紋相同的接線歸為一類** (功能等價)

適用於**小規模問題** (N ≤ 5)，是理解 pin swapping 問題的好工具。

大規模問題需要更進階的演算法。
